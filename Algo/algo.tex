\documentclass{article}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{ctex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{ulem}
\usetikzlibrary {positioning}
\title{一种基于口胡的KMP算法介绍（雾）}
\date{QQ = 2091079816}
\author{23.计科.周致远}
\begin{document}
	\maketitle


	众所周知，字符串模式匹配是计算机科学最为古老的问题之一。朴素的字符串匹配算法可以描述为：对于待匹配字符串（下称之为文本）的每一个位置，逐个字符比较从该位置开始是否与模式串（下称之为模板）完全匹配。时间复杂度为$O(n*m)$，十分低效。于是，我斗胆用我笨拙的语言介绍一种更快、更优雅，而且基本是线性复杂度的字符串匹配算法——KMP算法(The Knuth-Morris-Pratt Algorithm)。

	KMP的思想是充分利用朴素算法忽略的信息来加快匹配。假设有如下文本：

	$$goodgoogle$$

	和以下模板：

	$$google$$


	则朴素的方法可表示为：\\

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {g};
		\node [correct] (b2) [right=2mm of b1]{o};
		\node [correct] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [place] (b5) [right=2mm of b4]{g};
		\node [place] (b6) [right=2mm of b5]{o};
		\node [place] (b7) [right=2mm of b6]{o};
		\node [place] (b8) [right=2mm of b7]{g};
		\node [place] (b9) [right=2mm of b8]{l};
		\node [place] (b10) [right=2mm of b9]{e};

		\node [correct] (a1) [below =of b1]{g};
		\node [correct] (a2) [right=2mm of a1]{o};
		\node [correct] (a3) [right=2mm of a2]{o};
		\node [place] (a4) [right=2mm of a3]{g};
		\node [place] (a5) [right=2mm of a4]{l};
		\node [place] (a6) [right=2mm of a5]{e};

		\draw [->] (b1) to (a1);
		\draw [->] (b2) to (a2);
		\draw [->] (b3) to (a3);
		\draw [red, ->] (b4) -- (a4) node [midway] {$\times$};

	\end{tikzpicture}
	\end{centering}

	\vspace{1cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [place] (b1) {g};
		\node [place] (b2) [right=2mm of b1]{o};
		\node [place] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [place] (b5) [right=2mm of b4]{g};
		\node [place] (b6) [right=2mm of b5]{o};
		\node [place] (b7) [right=2mm of b6]{o};
		\node [place] (b8) [right=2mm of b7]{g};
		\node [place] (b9) [right=2mm of b8]{l};
		\node [place] (b10) [right=2mm of b9]{e};

		\node [place] (a1) [below =of b2]{g};
		\node [place] (a2) [right=2mm of a1]{o};
		\node [place] (a3) [right=2mm of a2]{o};
		\node [place] (a4) [right=2mm of a3]{g};
		\node [place] (a5) [right=2mm of a4]{l};
		\node [place] (a6) [right=2mm of a5]{e};

		\draw [red, ->] (b2) -- (a1) node [midway] {$\times$};

	\end{tikzpicture}
	\end{centering}

	\vspace{1cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [place] (b1) {g};
		\node [place] (b2) [right=2mm of b1]{o};
		\node [place] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [place] (b5) [right=2mm of b4]{g};
		\node [place] (b6) [right=2mm of b5]{o};
		\node [place] (b7) [right=2mm of b6]{o};
		\node [place] (b8) [right=2mm of b7]{g};
		\node [place] (b9) [right=2mm of b8]{l};
		\node [place] (b10) [right=2mm of b9]{e};

		\node [place] (a1) [below =of b3]{g};
		\node [place] (a2) [right=2mm of a1]{o};
		\node [place] (a3) [right=2mm of a2]{o};
		\node [place] (a4) [right=2mm of a3]{g};
		\node [place] (a5) [right=2mm of a4]{l};
		\node [place] (a6) [right=2mm of a5]{e};

		\draw [red, ->] (b3) -- (a1) node [midway] {$\times$};

	\end{tikzpicture}
	\end{centering}

	$$ 2\  steps\  later ... $$

	\vspace{0.7cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [place] (b1) {g};
		\node [place] (b2) [right=2mm of b1]{o};
		\node [place] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [correct] (b5) [right=2mm of b4]{g};
		\node [correct] (b6) [right=2mm of b5]{o};
		\node [correct] (b7) [right=2mm of b6]{o};
		\node [correct] (b8) [right=2mm of b7]{g};
		\node [correct] (b9) [right=2mm of b8]{l};
		\node [correct] (b10) [right=2mm of b9]{e};

		\node [correct] (a1) [below =of b5]{g};
		\node [correct] (a2) [right=2mm of a1]{o};
		\node [correct] (a3) [right=2mm of a2]{o};
		\node [correct] (a4) [right=2mm of a3]{g};
		\node [correct] (a5) [right=2mm of a4]{l};
		\node [correct] (a6) [right=2mm of a5]{e};

		\draw [->] (b5) -- (a1);
		\draw [->] (b6) -- (a2);
		\draw [->] (b7) -- (a3);
		\draw [->] (b8) -- (a4);
		\draw [->] (b9) -- (a5);
		\draw [->] (b10) -- (a6);

	\end{tikzpicture}
	\end{centering}

	设文本表示为 $\{s_1, s_2 , ... , s_10\}$；模板表示为 $\{t_1, t_2, ... , t_6\}$（下同），
	我们发现，即便出现三个字符"goo"="goo"匹配的特殊情况，朴素算法也会无视这一点，直接跳到文本下一位和模板初始位。实际上，其中仍有可挖掘的信息：部分匹配给予了算法关于文本的一部分知识。基于朴素匹配算法，设模板长度为n，文本长度为$n_t$，如果把模板看成一个n维向量：

	$$ T = 
	\left[\begin{array}{c} 
			\color{green!50!black}\mathbf{g} \\ 
			\color{green!50!black}\mathbf{o} \\
			\color{green!50!black}\mathbf{o} \\
			g \\ 
			l \\
			e
	\end{array}\right]
	$$

	把朴素算法匹配文本的过程看成n维空间：

	$$
	S = 
	\left[\begin{array}{cccccc}
			\color{green!50!black}\mathbf{g} & \color{green!50!black}\mathbf{o} & \color{green!50!black}\mathbf{o} & d & g & o \\
			o&o&d&g&o&o \\ 
			o&d&g&o&o&g \\
			d&g&o&o&g&l \\
			g&o&o&g&l&e 
	\end{array}\right]
	$$
	
	字符串模式匹配$S \times T$过程中观察矩阵$S$，第一行已经匹配出"goo"，接下来要匹配的几行的前三个字符与"goo"都不完全相同：

	$$
	\left[\begin{array}{cccccc}
			\color{green!50!black}\mathbf{g} & \color{green!50!black}\mathbf{o} & \color{green!50!black}\mathbf{o} & d & g & o \\
			\color{red}\mathbf{o}&\color{red}\mathbf{o}&\color{blue}\mathbf{d}&g&o&o \\ 
			\color{red}\mathbf{o}&\color{blue}\mathbf{d}&\color{blue}\mathbf{g}&o&o&g \\
			\color{blue}\mathbf{d}&\color{blue}\mathbf{g}&\color{blue}\mathbf{o}&o&g&l \\
			g&o&o&g&l&e 
	\end{array}\right]
	$$

	若称从开头开始的连续子串为前缀，从末尾开始的连续子串为后缀,标为红色的元素与模板的后缀相同，而且接下来还要和模板前缀匹配。因此，由于前缀匹配是完整匹配的必要条件，如果能让模板自己的后缀和自己前缀比较，那么就可以在不处理文本接下来字符的情况下直接略过下几次判断，来找到满足必要条件的需要处理的情况：

	\vspace{0.7cm}

	%此时我们已知在当前位置，文本和模板的前三位相等且为"goo"；而下一次匹配时的前两位为"oo"，再下一次匹配的前一位为"o"，这就是我们根据相等获得的额外信息。所以，只要"go"!="oo"则可以跳过下一条、"g"!="o"则可以跳过再下一条，可惜再下次匹配的前三位已经不包含任何第一次的字符了，根据已知信息已经无法跳过更多匹配，于是在这停顿。

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {g};
		\node [correct] (b2) [right=2mm of b1]{o};
		\node [correct] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [place] (b5) [right=2mm of b4]{g};
		\node [place] (b6) [right=2mm of b5]{o};
		\node [place] (b7) [right=2mm of b6]{o};
		\node [place] (b8) [right=2mm of b7]{g};
		\node [place] (b9) [right=2mm of b8]{l};
		\node [place] (b10) [right=2mm of b9]{e};

		\node [correct] (a1) [below =of b2]{g};
		\node [correct] (a2) [right=2mm of a1]{o};
		\node [correct] (a3) [right=2mm of a2]{o};
		\node [place] (a4) [right=2mm of a3]{...};

		\draw [red, ->] (b2) -- (a1) node [midway]{$\times$};
		\draw [red, ->] (b3) -- (a2) node [midway] {$\times$};

	\end{tikzpicture}
	\end{centering}
	
	和

	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {g};
		\node [correct] (b2) [right=2mm of b1]{o};
		\node [correct] (b3) [right=2mm of b2]{o};
		\node [place] (b4) [right=2mm of b3]{d};
		\node [place] (b5) [right=2mm of b4]{g};
		\node [place] (b6) [right=2mm of b5]{o};
		\node [place] (b7) [right=2mm of b6]{o};
		\node [place] (b8) [right=2mm of b7]{g};
		\node [place] (b9) [right=2mm of b8]{l};
		\node [place] (b10) [right=2mm of b9]{e};

		\node [correct] (a1) [below =of b3]{g};
		\node [correct] (a2) [right=2mm of a1]{o};
		\node [correct] (a3) [right=2mm of a2]{o};
		\node [place] (a4) [right=2mm of a3]{...};

		\draw [red, ->] (b3) -- (a1) node [midway]{$\times$};

	\end{tikzpicture}
	\end{centering}

	滑动的过程中，我们发现"oo"和"go"分别是部分匹配的后两位、前两位；"o"和"g"则分别是最后一位、第一位，正是模版的子串的长度为2、1的前后缀。于是可以看出，\textbf{根据已知信息的判断其实是判断已知部分的前后缀是否相等！}如果相等，那么在这个位置可以匹配，否则不需要考虑。更好的是，模版子串的前后缀是否相等是可以进行预处理得到的，我们可以只处理那些相等的情况。而这就是KMP算法的主要思想所在，如果我们能预先处理出模板每个子串的最大前后缀长度，就能预先判断每次部分匹配失败后下次第一个需要处理的情况。让我们再看一组例子：

	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		correct2/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct2] (b1) {a};
		\node [correct2] (b2) [right=2mm of b1]{b};
		\node [correct2] (b3) [right=2mm of b2]{c};
		\node [correct2] (b4) [right=2mm of b3]{a};
		\node [correct2] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [correct2] (a1) [below =of b1]{a};
		\node [correct2] (a2) [right=2mm of a1]{b};
		\node [correct2] (a3) [right=2mm of a2]{c};
		\node [correct2] (a4) [right=2mm of a3]{a};
		\node [correct2] (a5) [right=2mm of a4]{b};

		\draw [->] (b1) -- (a1) {};
		\draw [->] (b2) -- (a2) {};
		\draw [->] (b3) -- (a3) {};
		\draw [->] (b4) -- (a4) {};
		\draw [->] (b5) -- (a5) {};

	\end{tikzpicture}
	\end{centering}


	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {a};
		\node [correct] (b2) [right=2mm of b1]{b};
		\node [correct] (b3) [right=2mm of b2]{c};
		\node [correct] (b4) [right=2mm of b3]{a};
		\node [correct] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [correct] (a1) [below =of b2]{a};
		\node [correct] (a2) [right=2mm of a1]{b};
		\node [correct] (a3) [right=2mm of a2]{c};
		\node [correct] (a4) [right=2mm of a3]{a};
		\node [correct] (a5) [right=2mm of a4]{b};
		\node (a6) [right=2mm of a5] {不进行此次判断};

		\draw [->] (b2) -- (a1) node [midway]{$?$};

	\end{tikzpicture}
	\end{centering}

	
	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {a};
		\node [correct] (b2) [right=2mm of b1]{b};
		\node [correct] (b3) [right=2mm of b2]{c};
		\node [correct] (b4) [right=2mm of b3]{a};
		\node [correct] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [correct] (a1) [below =of b3]{a};
		\node [correct] (a2) [right=2mm of a1]{b};
		\node [correct] (a3) [right=2mm of a2]{c};
		\node [correct] (a4) [right=2mm of a3]{a};
		\node [correct] (a5) [right=2mm of a4]{b};
		\node (a6) [right=2mm of a5] {不进行此次判断};

		\draw [->] (b3) -- (a1) node [midway]{$?$};

	\end{tikzpicture}
	\end{centering}

	
	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		correct2/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {a};
		\node [correct] (b2) [right=2mm of b1]{b};
		\node [correct] (b3) [right=2mm of b2]{c};
		\node [correct2] (b4) [right=2mm of b3]{a};
		\node [correct2] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [correct2] (a1) [below =of b4]{a};
		\node [correct2] (a2) [right=2mm of a1]{b};
		\node [correct] (a3) [right=2mm of a2]{c};
		\node [correct] (a4) [right=2mm of a3]{a};
		\node [correct] (a5) [right=2mm of a4]{b};
		\node (a6) [right=2mm of a5] {第一个需要处理的情况};

		\draw [red, ->] (b6) -- (a3) node [midway]{$\times$};

	\end{tikzpicture}
	\end{centering}

	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		correct2/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [correct] (b1) {a};
		\node [correct] (b2) [right=2mm of b1]{b};
		\node [correct] (b3) [right=2mm of b2]{c};
		\node [correct] (b4) [right=2mm of b3]{a};
		\node [correct] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [correct] (a1) [below =of b5]{a};
		\node [correct] (a2) [right=2mm of a1]{b};
		\node [correct] (a3) [right=2mm of a2]{c};
		\node [correct] (a4) [right=2mm of a3]{a};
		\node [correct] (a5) [right=2mm of a4]{b};
		\node (a6) [right=2mm of a5] {不进行此次判断};

		\draw [->] (b5) -- (a1) node [midway]{$?$};

	\end{tikzpicture}
	\end{centering}

	\vspace{0.5cm}

	\begin{centering}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}
		[place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		correct2/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]
		\node [place] (b1) {a};
		\node [place] (b2) [right=2mm of b1]{b};
		\node [place] (b3) [right=2mm of b2]{c};
		\node [place] (b4) [right=2mm of b3]{a};
		\node [place] (b5) [right=2mm of b4]{b};
		\node [place] (b6) [right=2mm of b5]{d};
		\node [place] (b7) [right=2mm of b6]{e};
		\node [place] (b8) [right=2mm of b7]{f};
		\node [place] (b9) [right=2mm of b8]{j};
		\node [place] (b10) [right=2mm of b9]{k};

		\node [place] (a1) [below =of b6]{a};
		\node [place] (a2) [right=2mm of a1]{b};
		\node [place] (a3) [right=2mm of a2]{c};
		\node [place] (a4) [right=2mm of a3]{a};
		\node [place] (a5) [right=2mm of a4]{b};

		\draw [red, ->] (b6) -- (a1) node [midway]{$\times$};

	\end{tikzpicture}
	\end{centering}


	此时满足：

	\begin{center}
	\usetikzlibrary {arrows.meta, positioning}
	\begin{tikzpicture}[bend angle=45,
		place/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=0pt, minimum size=10mm},
		correct/.style={circle,draw=blue!50,fill=red!20,thick,inner sep=0pt, minimum size=10mm},
		correct2/.style={circle,draw=blue!50,fill=green!20,thick,inner sep=0pt, minimum size=10mm},
		transition/.style={rectangle,draw=black!50,fill=black!20,thick, inner sep=0pt, minimum size=6mm}]

		\node [correct] (a3) {c};
		\node [correct2] (a4) [right=2mm of a3]{a};
		\node [correct2] (a5) [right=2mm of a4]{b};

		\node [correct2] (a2) [left=2mm of a3]{b}
			edge [bend left] node [above] {=}   (a5);
		\node [correct2] (a1) [left=2mm of a2] {a}
			edge [bend left] node [above] {=}  (a4);
	\end{tikzpicture}
	\end{center}

	称"abcab"有长度为2的最大相等前后缀。遇到不匹配的情况，直接跳转到已经匹配部分之后的下一个字符，让最大相等前后缀来决定此时模板的指针在何处。无论如何，\textbf{每一个文本字符只被匹配一次}（已经匹配部分不会再次匹配 \sout{kmp也是线性筛}），时间复杂度为线性，这就是kmp的原理。

	具体而言，命题：

	\textbf{文本字符串$\{s_1,s_2...s_k,...,s_{k+q-1},...,s_n\}$和模版字符串$\{t_1,...,t_q,...t_m\}$的匹配部分 
	$ \{t_1, ..., t_q\}$的最大相同前后缀长度为$max$,则$\{s_{k},...,s_{k+max-1}\}$到$\{s_{k+max-1},...,s_{k+max+max-2}\}$
一定不能与$\{t_1,...,t_{max}\}$匹配。}

	一定成立。否则，会有新的最大相同前后缀。

	对模版进行预处理，每个前缀存储它的最大相等前后缀长度，设next[i]为模版的前i个字符的最大相同前后缀长度，此时有如下转移方程：

\begin{equation}
	\left\{
		\begin{aligned}
			&next[i] = next[i-1]+1, \ t_i = t_{next[i-1]} &\\
			&next[i] = next[next[i-1]]+1, \ t_i = t_{next[next[i-1]]} &
		\end{aligned}
	\right.
\end{equation}

当最大相等前后缀可以延续时，下一个next加一；当无法延续时，尝试使用上一个最大相等前后缀A的最大相等前后缀B来延续（因为B仍是当前子串相等前后缀之一）。获得next数组后，在进行文本匹配时就可以：

- 匹配成功：继续匹配，匹配成功子串长度+1

- 匹配失败：继续匹配，但模版指针跳到next[成功子串长度]位置

	可以看出，无论匹配是否成功，算法总会跳到文本串的下一个字符，并且根据最长相同前后缀确定模版串指针位置，这使得复杂度成为线性。根据以上解析，可写出预处理模版串代码：

\begin{verbatim}
void getnext(){
	next[0] = 0;
	for(int i = 1;i < ns; i++){
	  if(sub[i] == sub[next[i-1]]) next[i] = next[i-1]+1;
	  else if(next[i-1] == 0) continue;
	  else if(sub[next[next[i-1]-1]] == sub[i]){
		next[i] = next[next[i-1]-1] + 1;
	  }
	  else if(sub[0] == sub[i]) next[i] = 1;
	}
  }
\end{verbatim}

以及匹配过程：

\begin{verbatim}
	void kmp(){
		int cur = 0;
		for(int i = 0 ; i < n ; i++){
			if(str[i] == sub[cur]){
				cur ++;
				if(cur == ns){
					cout << i-ns+2 << endl;
					cur = next[cur-1];
				}
			}
			else if(cur != 0){
				cur = next[cur-1];
				i--;
			}
		}
		return;
	}
\end{verbatim}

时间复杂度$O(n+m)$。值得一提的是，kmp算法在数据库、ide、文本编辑器中广泛使用，你的vscode中或许就不时跑着这个算法。至此，KMP算法介绍完毕。

\end{document}
